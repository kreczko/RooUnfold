// File and Version Information:
//      $Id: RooUnfoldTestHarness.icc,v 1.3 2010-01-16 01:58:39 adye Exp $
//
// Description:
//      Tests RooUnfold package using toy MC generated according to PDFs defined
//      in RooUnfoldTestPdf.icc or RooUnfoldTestPdfRooFit.icc.
//
// Author List:
//      Tim Adye <T.J.Adye@rl.ac.uk>
//      Fergus Wilson <F.F.Wilson@rl.ac.uk>
//
// Copyright Information:
//      Copyleft (C) 2005-10    Rutherford Appleton Laboratory
//
//==============================================================================

#ifndef ROOUNFOLDTESTHARNESS_ICC
#define ROOUNFOLDTESTHARNESS_ICC

#include "RooUnfoldTestHarness.h"

#ifndef NOROOFIT
#define USE_ROOFIT
#endif

#include <cfloat>
#if !defined(__CINT__) || defined(__MAKECINT__)
#include <cmath>
#include <iostream>

#include "TROOT.h"
#include "TString.h"
#include "TStyle.h"
#include "TCanvas.h"
#include "TRandom.h"
#include "TPostScript.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TFile.h"
#include "TVectorD.h"
#include "TLine.h"

#include "RooUnfoldResponse.h"
#include "RooUnfoldBayes.h"
#include "RooUnfoldSvd.h"
#include "RooUnfoldBinByBin.h"
#endif

#include "RooUnfoldTestArgs.icc"

//==============================================================================
// MC generation routine: RooUnfoldTestPdf()
// This routine is included inline so it does not have to be part of the library
// and does not need to be loaded explicitly from the ROOT prompt.
//==============================================================================

#ifdef USE_ROOFIT
#include "RooUnfoldTestPdfRooFit.icc"
#else
#include "RooUnfoldTestPdf.icc"
#endif

#if !defined(__CINT__) || defined(__MAKECINT__)
using std::fabs;
using std::cout;
using std::cerr;
using std::endl;
#endif

//==============================================================================
// Utility routines
//==============================================================================

//==============================================================================
// Set histogram Y-axis display range
//==============================================================================

void RooUnfoldTestHarness::setmax (TH1* h,
                                   const TH1* h1, const TH1* h2, const TH1* h3,
                                   const TH1* h4, const TH1* h5, const TH1* h6)
{
  // Get the maximum y value of up to 7 histograms
  // Add 10% to match behaviour of ROOT's automatic scaling
  Double_t maxval= h1 ? h1->GetMaximum() : -DBL_MAX;
  if (h2 && h2->GetMaximum() > maxval) maxval= h2->GetMaximum();
  if (h3 && h3->GetMaximum() > maxval) maxval= h3->GetMaximum();
  if (h4 && h4->GetMaximum() > maxval) maxval= h4->GetMaximum();
  if (h5 && h5->GetMaximum() > maxval) maxval= h5->GetMaximum();
  if (h6 && h6->GetMaximum() > maxval) maxval= h6->GetMaximum();
  if (maxval > h->GetMaximum()) h->SetMaximum (1.1*maxval);
}

//==============================================================================
// Gaussian smearing, systematic translation, and variable inefficiency
//==============================================================================

Double_t RooUnfoldTestHarness::smear (Double_t xt, Int_t nt, Double_t xlo, Double_t xhi)
{
  // Apply a gaussian smearing, systematic translation, and an efficiency
  // function to the truth.
  // Efficiency: 30% at x=xlo, 100% at x=xhi.
  // Shift = -10% of the range.
  // Smear = half a bin width.

  const Double_t ylo= 0.3, yhi= 1.0, relshift= -0.1, binsmear= 0.5;
  Double_t xwidth =  (xhi-xlo);

  Double_t slope = (yhi-ylo) / xwidth;
  Double_t yeff= ylo + slope * (xt-xlo);  // efficiency

  // MC test: if random number > eff then reject
  if (gRandom->Rndm() > yeff)  return cutdummy;
  if (nosmear) return xt;   // bin-by-bin correction can't handle bias and smearing

  Double_t xshift = xwidth*relshift;                 // shift
  Double_t xsigma = xwidth*binsmear / Double_t(nt);  // smear sigma

  Double_t xsmear= gRandom->Gaus(xshift, xsigma);     // bias and smear
  //cout << "SMEAR " << xt << " " << xsmear << " " << xwidth << " " << xsigma << endl;
  return xt+xsmear;
}

//==============================================================================
// Train unfolding algorithm
//==============================================================================

Int_t RooUnfoldTestHarness::Train()
{
  const Int_t nbPDF= 500;
  TVectorD xtrue(ntrain);
  hPDF= new TH1D ("trainpdf", "Training PDF", nbPDF, xlo, xhi);
  hPDF->SetLineColor(kGreen);
  hPDF->SetLineWidth(2);
  if (!RooUnfoldTestPdf (ftrainx, ntrain, xlo, xhi, xtrue, hPDF)) return 0;
  hPDF->Scale (nbPDF/Double_t(nt));


  hTrainTrue= new TH1D ("traintrue", "Training Truth", nt, xlo, xhi);
  hTrainTrue->SetLineColor(kBlue);
  hTrain= new TH1D ("train", "Training Measured", nm, xlo, xhi);
  hTrain->SetLineColor(kRed);
  hResmat= new TH2D ("resmat", "Response Matrix", nm, xlo, xhi, nt, xlo, xhi);

  response->Setup (nm, xlo, xhi, nt, xlo, xhi);
  //  response->Setup (hTrain, hTrainTrue);

  for (Int_t i= 0; i<ntrain; i++) {
    Double_t xt= xtrue[i];
    hTrainTrue->Fill (xt);
    Double_t x= smear (xt, nt, xlo, xhi);
    if (x!=cutdummy) {
      hTrain ->Fill (x);
      hResmat->Fill  (x, xt);
      response->Fill (x, xt);
    } else
      response->Miss (xt);
  }

  //  response->Setup (hTrain, hTrainTrue, hResmat);

  setmax (hTrainTrue, hPDF, hTrain);

  if (onepage>=4) canvas->cd(++ipad);
  if (!onepage || onepage >= 4) {
    hTrainTrue->Draw();
    hPDF      ->Draw("LSAME");
    hTrain    ->Draw("SAME");
    canvas->Update();
  }

  return 1;
}

//==============================================================================
// Test distribution
//==============================================================================

Int_t RooUnfoldTestHarness::Test()
{
  const Int_t nbPDF= 500;
  TVectorD xtest(ntest);
  hTestPDF= new TH1D ("pdf", "PDF", nbPDF, xlo, xhi);
  hTestPDF->SetLineColor(kGreen); // green
  hTestPDF->SetLineWidth(2);
  if (!RooUnfoldTestPdf (ftestx, ntest, xlo, xhi, xtest, hTestPDF, 1.0, 2.0)) return 0;
  hTestPDF->Scale (nbPDF/Double_t(nt));

  hTrue= new TH1D ("true", "Test Truth", nt, xlo, xhi);
  hTrue->SetLineColor(kBlue); // Blue
  hMeas= new TH1D ("meas", "Test Measured", nm, xlo, xhi);
  hMeas->SetLineColor(kRed); // Red
  for (Int_t i=0; i<ntest ; i++) {
    Double_t xt= xtest[i];
    hTrue->Fill(xt);
    Double_t x = smear (xt, nt, xlo, xhi);
    if (x!=cutdummy)
      hMeas->Fill(x);
  }

  return 1;
}

//==============================================================================
// Unfold
//==============================================================================

void RooUnfoldTestHarness::Unfold()
{
  cout << "Create RooUnfold object for method " << method << endl;
  switch (method) {
    case 1:  unfold= new RooUnfoldBayes    (response, hMeas, regparm);
             break;
    case 2:  unfold= new RooUnfoldSvd      (response, hMeas, regparm, ntoys);
             break;
    case 3:  unfold= new RooUnfoldBinByBin (response, hMeas);
             break;
    default: cerr << "Unknown RooUnfold method " << method << endl;
             return;
  }
  cout << "Created "; unfold->Print();

  // Unfolded distribution
  hReco= (TH1D*) unfold->Hreco();
  unfold->PrintTable (cout, hTrue);

  hReco->SetLineColor(kBlack);
  hReco->SetMarkerStyle(kFullDotLarge);
  setmax (hTrue, hTestPDF, hMeas, hReco);

  if (onepage) canvas->cd(++ipad);
  hTrue   ->Draw();
  hTestPDF->Draw("LSAME");
  hMeas   ->Draw("SAME");
  hReco   ->Draw("SAME");
  // canvas->Update();

  // I think hReco already includes the statistical error on hTrue, so
  // don't include that twice when calculating residuals.
  hTrue0= (TH1D*) hTrue->Clone();
  hTrue0->SetNameTitle("true0", "Truth with zero errors");
  for (Int_t i = 0 ; i <= nt+1 ; i++)
    hTrue0->SetBinError (i, 0.0);

  hRes= new TH1D ("reco-true", "Residuals", nt, xlo, xhi);
  hRes->SetMarkerStyle(kFullDotLarge);
  hRes->Sumw2();
  hRes->Add (hTrue0, hReco, -1, 1);

  if (onepage>=2) canvas->cd(++ipad);
  if (!onepage || onepage >= 2) {
    hRes->Draw();
    TLine l; // draw a line at y=0;
    l.DrawLine(hRes->GetBinLowEdge(1), 0.0, hRes->GetBinLowEdge(nt+1), 0.0);
    //   canvas->Update();
  }

  // how about doing some pulls
  hPulls = new TH1D ("pulls", "Pulls", nt, xlo, xhi);
  const Double_t MAXPULL = 5.0;

  for (Int_t i = 0 ; i <= nt+1; i++) {

    Double_t ydiff    = hRes->GetBinContent(i);
    Double_t ydiffErr = hRes->GetBinError(i);

    Double_t ypull;
    if (ydiffErr==0) {
      ypull= ydiff> 0 ? MAXPULL : -MAXPULL;
    } else {
      ypull = ydiff/ydiffErr;
    }

    //cout << ypull << " " << ydiffErr << endl;

    if (fabs(ypull)<=MAXPULL) {
      hPulls->SetBinContent(i,ypull);
      hPulls->SetBinError(i,1.0);
    }
  }

  if (onepage>=2) canvas->cd(++ipad);
  if (!onepage || onepage >= 2) {
    hPulls->SetMarkerStyle(kFullDotLarge);
    hPulls->Draw("P");
    TLine l; // draw a line at y=0;
    l.DrawLine(hPulls->GetBinLowEdge(1), 0.0, hPulls->GetBinLowEdge(nt+1), 0.0);
    //    canvas->Update();
  }
 canvas->Update();

}

void RooUnfoldTestHarness::Print (std::ostream& o) const
{
  o << GetName() << " (";
  const setargs_t* args;
  int nargs= const_cast<RooUnfoldTestHarness*>(this)->Parms (args);
  for (int j= 0; j<nargs; j++) {
    if (j>0) o << ", ";
    o << args[j].name << '=';
    if (args[j].ivar) o << *(args[j].ivar);
    else              o << *(args[j].fvar);
  }
  o << ')' << endl;
}

Int_t RooUnfoldTestHarness::Check()
{
  // some stupid tests
  if (xlo >= xhi) {cout << "Error: xlo ("    << xlo    << ") >= xhi(" << xhi << ")" << endl; error = 2;}
  if (ntest<=0)   {cout << "Error: ntest ("  << ntest  << ") <= 0"                  << endl; error = 2;}
  if (ntrain<=0)  {cout << "Error: ntrain (" << ntrain << ") <= 0"                  << endl; error = 2;}
  if (nm<=0)      {cout << "Error: nm ("     << nm     << ") <= 0"                  << endl; error = 2;}
  if (nt<=0)      {cout << "Error: nt ("     << nt     << ") <= 0"                  << endl; error = 2;}
  if (ftestx<1)   {cout << "Error: ftestx (" << ftestx << ") < 1"                   << endl; error = 2;}
  if (ftrainx<1)  {cout << "Error: ftrainx ("<< ftrainx<< ") < 1"                   << endl; error = 2;}
  return error;
}

Int_t RooUnfoldTestHarness::Run()
{
  if (error) return error;
  if (nm==-1) nm= nt;
  if (regparm==-999) regparm= (method==1 ? 4 : method==2 ? (nt>5 ? nt/2 : 2) : 0);
  if (method == 3) nosmear= true;  // bin-by-bin can't handle smearing or bias
  Print (cout);
  Check();
  if (error) return error;

  gROOT->SetStyle("Plain");
  gStyle->SetOptStat(0);
  TPostScript ps(TString(GetName())+".ps", 111);
  canvas= new TCanvas(GetName(),GetName(),1);
  //canvas= new TCanvas(GetName(),GetName(),10,10,900,500);
  canvas->Clear();

  if (onepage==2) {
    gStyle->SetPadTopMargin(0.05);
    gStyle->SetPadRightMargin(0.02);
    gStyle->SetPadBottomMargin(0.08);
    gStyle->SetPadLeftMargin(0.06);
    canvas->Divide(1,2);
    TPad* pad1= (TPad*) canvas->GetPad(1);
    TPad* pad2= (TPad*) canvas->GetPad(2);
    pad1->SetPad (pad1->GetXlowNDC(), .3, pad1->GetXlowNDC()+pad1->GetWNDC(), pad1->GetYlowNDC()+pad1->GetHNDC());
    pad2->SetPad (pad2->GetXlowNDC(), pad2->GetYlowNDC(), pad2->GetXlowNDC()+pad2->GetWNDC(), .3);
    pad1->SetGrid(1);
    pad2->SetGrid(1);
  } else if (onepage>=6) {
    canvas->SetGrid();
    canvas->Divide(2,(onepage+1)/2);
  } else if (onepage>=3)
    canvas->Divide(1,onepage);
  else
    canvas->SetGrid(1);
  ipad= 0;

  if (stage != 2) {
    response= new RooUnfoldResponse ("response", "test 1-D Unfolding");
    if (!response) return 3;
    cout   << "==================================== TRAIN ====================================" << endl;
    if (Train()) {
      TFile f (TString(GetName())+".root", "recreate");
      f.WriteTObject (response, "response");
      f.Close();
    } else
      return 4;   // training failed - skip testing
  }

  if (stage != 1) {
    if (!response) {
      TFile f (TString(GetName())+".root");
      f.GetObject ("response", response);
      f.Close();
      if (!response) {
        cerr << "could not read 'response' object from file RooUnfoldTest.root" << endl;
        return 5;
      }
    }
    cout   << "==================================== TEST =====================================" << endl;
    if (Test()) {
      cout << "==================================== UNFOLD ===================================" << endl;
      Unfold();
    }
  }

  ps.Close();
  return 0;
}

//==============================================================================
// Constructor
//==============================================================================

RooUnfoldTestHarness::RooUnfoldTestHarness (const char* name)
  : TNamed(name,name)
{
  Reset();
}

RooUnfoldTestHarness::RooUnfoldTestHarness (const char* name, int argc, const char* const* argv)
  : TNamed(name,name)
{
  Reset();
  error= SetArgs (argc, argv);
}

RooUnfoldTestHarness::RooUnfoldTestHarness (const char* name, const char* args)
  : TNamed(name,name)
{
  Reset();
  const char* const argv[]= { name, args };
  error= SetArgs (2, argv, true);
}

RooUnfoldTestHarness::~RooUnfoldTestHarness()
{
  delete response; response= 0;
  delete unfold;   unfold=   0;
  delete canvas;   canvas=   0;
}

void RooUnfoldTestHarness::Reset()
{
  response= 0;
  unfold= 0;
  canvas= 0;
  hPDF= hTestPDF= hTrain= hTrainTrue= hTrue= hMeas= hReco= hTrue0= hRes= hPulls= 0;
  hResmat= 0;
  nosmear= false;
  error= ipad= 0;
  Defaults();
}

int RooUnfoldTestHarness::Parms (const setargs_t*& args)
{
  RooUnfoldTestHarness* h= this;   // work round CINT bug: reference our parameters via h
  static const setargs_t sargs[]= {
    { "method",  &h->method,  0 }, // RooUnfold method: 1=Bayes, 2=SVD, 3=bin-by-bin
    { "stage",   &h->stage,   0 }, // 1=train (writes RooUnfoldTest.root), 2=test (reads), 0=both (default)
    { "ftrain",  &h->ftrainx, 0 }, // selected training function
    { "ftest",   &h->ftestx,  0 }, // selected test function
    { "nt",      &h->nt,      0 }, // #truth bins
    { "ntest",   &h->ntest,   0 }, // #events to use for unsmearing
    { "ntrain",  &h->ntrain,  0 }, // #events to use for training
    { "xlo",     0,     &h->xlo }, // range minimum
    { "xhi",     0,     &h->xhi }, // range maximum
    { "regparm", &h->regparm, 0 }, // regularisation parameter (eg. number of iterations)
    { "ntoys",   &h->ntoys,   0 }, // number of toys used to obtain SVD covariances
    { "nm",      &h->nm,      0 }, // #measured bins
    { "onepage", &h->onepage, 0 }
  };
  args= sargs;
  return sizeof(sargs)/sizeof(setargs_t);
}

int RooUnfoldTestHarness::SetArgs (int argc, const char* const* argv, bool split)
{
  const setargs_t* args;
  int nargs= Parms (args);
  if (!setargs (args, nargs, argc, argv, split)) return 1;
  return 0;
}

void RooUnfoldTestHarness::Defaults()
{
  method=      1;
  stage=       0;
  ftrainx=     2;
  ftestx=      5;
  nt=         40;
  ntest=   10000;
  ntrain= 100000;
  xlo=     -12.5;
  xhi=      10.0;
  regparm=  -999;   // Bayes niter=4, SVD kterm=20
  ntoys=    1000;   // SVD only
  nm=         -1;
  onepage=     4;
}

#endif
